diff --git docroot/modules/contrib/password_policy/password_policy.module docroot/modules/contrib/password_policy/password_policy.module
index 6823ad7c8..357d92fc4 100644
--- docroot/modules/contrib/password_policy/password_policy.module
+++ docroot/modules/contrib/password_policy/password_policy.module
@@ -320,165 +320,171 @@ function password_policy_cron() {
   // Load each policy.
   $policies = \Drupal::entityTypeManager()->getStorage('password_policy')->loadMultiple();
   $current_time = \Drupal::time()->getRequestTime();
-
+  
+  //patch to enable password_policy for cms login user only
+  $current_user = \Drupal::currentUser();
+  $user = User::load($current_user->id());
+  
+  if(!$user->get('field_saml_initialised')->value){
   /** @var \Drupal\password_policy\Entity\PasswordPolicy $policy */
-  foreach ($policies as $policy) {
-    // Check each policy configured w/ a password expiration > than 0 days.
-    if ($policy->getPasswordReset() > 0) {
-      // Load user roles for policy.
-      $policy_roles = $policy->getRoles();
-
-      if (empty($policy_roles)) {
-        continue;
-      }
-
-      // Determine date user accounts expired.
-      $expire_timestamp = strtotime('-' . $policy->getPasswordReset() . ' days', $current_time);
-      $expire_date = \Drupal::service('date.formatter')->format($expire_timestamp, 'custom', DateTimeItemInterface::DATETIME_STORAGE_FORMAT, DateTimeItemInterface::STORAGE_TIMEZONE);
-
-      // Configurable limit to users per policy per run, to prevent OOM errors.
-      $threshold = \Drupal::config('password_policy.settings')->get('cron_threshold');
-      // Do not continue with User query if the policy's expire date is less
-      // than the install time of the module itself. This prevents the policy
-      // from immediately applying to all users after initial module install.
-      $install_time = \Drupal::state()->get('password_policy.install_time');
-      if ($install_time && $install_time >= $expire_date) {
-        $users = [];
-      }
-      // Get list of users based on conditionals from above.
-      else {
-        // Limit to active users.
-        $query = \Drupal::entityQuery('user')
-          ->accessCheck(TRUE)
-          ->condition('status', 1);
-
-        // Limit to roles set by policy configuration.
-        if (!in_array(AccountInterface::AUTHENTICATED_ROLE, $policy_roles)) {
-          $query->condition('roles', $policy_roles, 'IN');
-        }
-
-        // Create condition groups for users with no value for the
-        // `field_password_expiration` and `field_last_password_reset` fields.
-        // This will be _all users_ after initial module installation.
-        $notset_group = $query
-          ->andConditionGroup()
-          ->condition('field_password_expiration', NULL, 'IS NULL')
-          ->condition('field_last_password_reset', NULL, 'IS NULL');
-
-        // Add condition group for users with a `field_password_expiration`
-        // value and `field_last_password_reset` value less than or equal the
-        // current expire date for the policy.
-        $isset_group = $query
-          ->andConditionGroup()
-          ->condition('field_password_expiration', 0)
-          ->condition('field_last_password_reset', $expire_date, '<=');
-
-        // Combine and add groups to query.
-        $combined_group = $query
-          ->orConditionGroup()
-          ->condition($notset_group)
-          ->condition($isset_group);
-        $query->condition($combined_group);
-
-        // Limit the number of results to the cron threshold setting.
-        $query->condition('uid', 0, '>')
-          ->range(0, $threshold);
-
-        $valid_list = $query->execute();
-
-        // Check for externally authenticated users.
-        if (\Drupal::moduleHandler()->moduleExists('externalauth')) {
-          $authmap = \Drupal::service('externalauth.authmap');
-          foreach ($valid_list as $key => $uid) {
-            $external_ids = $authmap->getAll($uid);
-            if ($external_ids) {
-              // Exclude externally authenticated users.
-              unset($valid_list[$key]);
-            }
-          }
+    foreach ($policies as $policy) {
+      // Check each policy configured w/ a password expiration > than 0 days.
+      if ($policy->getPasswordReset() > 0) {
+        // Load user roles for policy.
+        $policy_roles = $policy->getRoles();
+  
+        if (empty($policy_roles)) {
+          continue;
         }
-
-        // Load User Objects.
-        $users = \Drupal::entityTypeManager()
-          ->getStorage('user')
-          ->loadMultiple($valid_list);
-      }
-
-      // Expire passwords.
-      /** @var \Drupal\user\UserInterface $user */
-      foreach ($users as $user) {
-        $user->set('field_password_expiration', '1');
-        $user->set('field_pending_expire_sent', '0');
-        $user->save();
-
-        if ($policy->getPasswordResetEmailValue()) {
-          // Send email notification if configured.
-          $mailManager = Drupal::service('plugin.manager.mail');
-          $module = 'password_policy';
-          $key = 'reset_password';
-          $to = $user->getEmail();
-          $link = Url::fromRoute('user.login', [], ['absolute' => TRUE])->toString();
-          $params['message'] = t('Your password has expired. Please visit the following link to reset your password: :link',
-            [':link' => $link]);
-          $langcode = $user->getPreferredLangcode();
-          $send = TRUE;
-          $mailManager->mail($module, $key, $to, $langcode, $params, NULL, $send);
+  
+        // Determine date user accounts expired.
+        $expire_timestamp = strtotime('-' . $policy->getPasswordReset() . ' days', $current_time);
+        $expire_date = \Drupal::service('date.formatter')->format($expire_timestamp, 'custom', DateTimeItemInterface::DATETIME_STORAGE_FORMAT, DateTimeItemInterface::STORAGE_TIMEZONE);
+  
+        // Configurable limit to users per policy per run, to prevent OOM errors.
+        $threshold = \Drupal::config('password_policy.settings')->get('cron_threshold');
+        // Do not continue with User query if the policy's expire date is less
+        // than the install time of the module itself. This prevents the policy
+        // from immediately applying to all users after initial module install.
+        $install_time = \Drupal::state()->get('password_policy.install_time');
+        if ($install_time && $install_time >= $expire_date) {
+          $users = [];
         }
-
-      }
-
-      $pending_days = $policy->getPasswordPendingValue();
-      sort($pending_days);
-      if ($policy->getPasswordResetEmailValue() && $pending_days) {
-        foreach ($pending_days as $pending_day) {
-          // Find users about to expire.
-          $delay = $policy->getPasswordReset() - $pending_day;
-          $pending_timestamp = strtotime('-' . $delay . ' days', $current_time);
-          $pending_date = \Drupal::service('date.formatter')->format($pending_timestamp, 'custom', DateTimeItemInterface::DATETIME_STORAGE_FORMAT, DateTimeItemInterface::STORAGE_TIMEZONE);
+        // Get list of users based on conditionals from above.
+        else {
+          // Limit to active users.
           $query = \Drupal::entityQuery('user')
             ->accessCheck(TRUE)
-            ->condition('status', 1)
-            ->condition('field_password_expiration', 0)
-            ->condition('field_last_password_reset', $pending_date, '<=')
-            ->condition('uid', 0, '>')
-            ->range(0, $threshold);
-
-          // We want to send notifications only for customers that have not
-          // yet received the notification for this period, or not received
-          // any notification.
-          $fieldPendingExpireSentCondition = $query->orConditionGroup();
-          $fieldPendingExpireSentCondition
-            ->condition('field_pending_expire_sent', NULL, 'IS')
-            ->condition('field_pending_expire_sent', 0, '=')
-            ->condition('field_pending_expire_sent', $pending_day, '>');
-
-          $query->condition($fieldPendingExpireSentCondition);
-
+            ->condition('status', 1);
+  
+          // Limit to roles set by policy configuration.
           if (!in_array(AccountInterface::AUTHENTICATED_ROLE, $policy_roles)) {
             $query->condition('roles', $policy_roles, 'IN');
           }
-
-          $pending_list = $query->execute();
+  
+          // Create condition groups for users with no value for the
+          // `field_password_expiration` and `field_last_password_reset` fields.
+          // This will be _all users_ after initial module installation.
+          $notset_group = $query
+            ->andConditionGroup()
+            ->condition('field_password_expiration', NULL, 'IS NULL')
+            ->condition('field_last_password_reset', NULL, 'IS NULL');
+  
+          // Add condition group for users with a `field_password_expiration`
+          // value and `field_last_password_reset` value less than or equal the
+          // current expire date for the policy.
+          $isset_group = $query
+            ->andConditionGroup()
+            ->condition('field_password_expiration', 0)
+            ->condition('field_last_password_reset', $expire_date, '<=');
+  
+          // Combine and add groups to query.
+          $combined_group = $query
+            ->orConditionGroup()
+            ->condition($notset_group)
+            ->condition($isset_group);
+          $query->condition($combined_group);
+  
+          // Limit the number of results to the cron threshold setting.
+          $query->condition('uid', 0, '>')
+            ->range(0, $threshold);
+  
+          $valid_list = $query->execute();
+  
+          // Check for externally authenticated users.
+          if (\Drupal::moduleHandler()->moduleExists('externalauth')) {
+            $authmap = \Drupal::service('externalauth.authmap');
+            foreach ($valid_list as $key => $uid) {
+              $external_ids = $authmap->getAll($uid);
+              if ($external_ids) {
+                // Exclude externally authenticated users.
+                unset($valid_list[$key]);
+              }
+            }
+          }
+  
+          // Load User Objects.
           $users = \Drupal::entityTypeManager()
             ->getStorage('user')
-            ->loadMultiple($pending_list);
-
-          foreach ($users as $user) {
-            $user->set('field_pending_expire_sent', $pending_day);
-            $user->save();
-
-            // Send pending expiration email.
+            ->loadMultiple($valid_list);
+        }
+  
+        // Expire passwords.
+        /** @var \Drupal\user\UserInterface $user */
+        foreach ($users as $user) {
+          $user->set('field_password_expiration', '1');
+          $user->set('field_pending_expire_sent', '0');
+          $user->save();
+  
+          if ($policy->getPasswordResetEmailValue()) {
+            // Send email notification if configured.
             $mailManager = Drupal::service('plugin.manager.mail');
             $module = 'password_policy';
-            $key = 'pending_password';
+            $key = 'reset_password';
             $to = $user->getEmail();
             $link = Url::fromRoute('user.login', [], ['absolute' => TRUE])->toString();
-            $params['message'] = t('Your password will expire in less than :pending days. Please visit the following link to reset your password: :link',
-              [':link' => $link, ':pending' => $pending_day]);
+            $params['message'] = t('Your password has expired. Please visit the following link to reset your password: :link',
+              [':link' => $link]);
             $langcode = $user->getPreferredLangcode();
             $send = TRUE;
             $mailManager->mail($module, $key, $to, $langcode, $params, NULL, $send);
           }
+  
+        }
+  
+        $pending_days = $policy->getPasswordPendingValue();
+        sort($pending_days);
+        if ($policy->getPasswordResetEmailValue() && $pending_days) {
+          foreach ($pending_days as $pending_day) {
+            // Find users about to expire.
+            $delay = $policy->getPasswordReset() - $pending_day;
+            $pending_timestamp = strtotime('-' . $delay . ' days', $current_time);
+            $pending_date = \Drupal::service('date.formatter')->format($pending_timestamp, 'custom', DateTimeItemInterface::DATETIME_STORAGE_FORMAT, DateTimeItemInterface::STORAGE_TIMEZONE);
+            $query = \Drupal::entityQuery('user')
+              ->accessCheck(TRUE)
+              ->condition('status', 1)
+              ->condition('field_password_expiration', 0)
+              ->condition('field_last_password_reset', $pending_date, '<=')
+              ->condition('uid', 0, '>')
+              ->range(0, $threshold);
+  
+            // We want to send notifications only for customers that have not
+            // yet received the notification for this period, or not received
+            // any notification.
+            $fieldPendingExpireSentCondition = $query->orConditionGroup();
+            $fieldPendingExpireSentCondition
+              ->condition('field_pending_expire_sent', NULL, 'IS')
+              ->condition('field_pending_expire_sent', 0, '=')
+              ->condition('field_pending_expire_sent', $pending_day, '>');
+  
+            $query->condition($fieldPendingExpireSentCondition);
+  
+            if (!in_array(AccountInterface::AUTHENTICATED_ROLE, $policy_roles)) {
+              $query->condition('roles', $policy_roles, 'IN');
+            }
+  
+            $pending_list = $query->execute();
+            $users = \Drupal::entityTypeManager()
+              ->getStorage('user')
+              ->loadMultiple($pending_list);
+  
+            foreach ($users as $user) {
+              $user->set('field_pending_expire_sent', $pending_day);
+              $user->save();
+  
+              // Send pending expiration email.
+              $mailManager = Drupal::service('plugin.manager.mail');
+              $module = 'password_policy';
+              $key = 'pending_password';
+              $to = $user->getEmail();
+              $link = Url::fromRoute('user.login', [], ['absolute' => TRUE])->toString();
+              $params['message'] = t('Your password will expire in less than :pending days. Please visit the following link to reset your password: :link',
+                [':link' => $link, ':pending' => $pending_day]);
+              $langcode = $user->getPreferredLangcode();
+              $send = TRUE;
+              $mailManager->mail($module, $key, $to, $langcode, $params, NULL, $send);
+            }
+          }
         }
       }
     }
